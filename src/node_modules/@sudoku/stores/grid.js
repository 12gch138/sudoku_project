import { BOX_SIZE, SENCODE_REGEX, SUDOKU_SIZE } from '@sudoku/constants';
import { getBoxPos } from '@sudoku/helpers';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { get, writable } from 'svelte/store';
import { difficulty } from './difficulty';

function createGrid() {
	const grid = writable((() => {
		let query = location.search;

		if (query.startsWith('?')) {
			query = query.slice(1);
		}

		if (query.trim().length !== 0 && SENCODE_REGEX.test(query)) {
			return decodeSencode(query);
		}

		return generateSudoku(get(difficulty));
	})());

	return {
		subscribe: grid.subscribe,

		generate: (_difficulty) => {
			grid.set(generateSudoku(_difficulty));
		},

		setSencode: (sencode) => {
			grid.set(decodeSencode(sencode));
		},

		get: (gridStore, x, y) => {
			return gridStore[y - 1][x - 1];
		},

		getSencode: (gridStore) => {
			return encodeSudoku(gridStore);
		},

		getHint: (gridStore, x, y) => {
			const solvedSudoku = solveSudoku(gridStore);
			return solvedSudoku[y - 1][x - 1];
		},

		isEmpty: (gridStore, x, y) => {
			return (gridStore[y - 1][x - 1] === 0);
		},

		isValid: (gridStore, userGridStore, x, y, value) => {
			// TODO: performance improvement (calculate once for all cells)
			x = x - 1;
			y = y - 1;

			for (let i = 0; i < SUDOKU_SIZE; i++) {
				if (i !== x && (gridStore[y][i] === value || userGridStore[y][i] === value)) return false;
				if (i !== y && (gridStore[i][x] === value || userGridStore[i][x] === value)) return false;
			}

			const boxPos = getBoxPos(x, y);
			const startX = boxPos.x * BOX_SIZE;
			const endX = startX + BOX_SIZE;
			const startY = boxPos.y * BOX_SIZE;
			const endY = startY + BOX_SIZE;
			for (let row = startY; row < endY; row++) {
				for (let col = startX; col < endX; col++) {
					if (row !== y && col !== x && (gridStore[row][col] === value || userGridStore[row][col] === value)) return false;
				}
			}

			return true;
		}
	};
}

export const grid = createGrid();

function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	return {
		subscribe: userGrid.subscribe,

		set: (x, y, value) => {
			userGrid.update(_grid => {
				_grid[y - 1][x - 1] = value;
				return _grid;
			});
		},

		reset: () => {
			userGrid.set([
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
				[0, 0, 0, 0, 0, 0, 0, 0, 0],
			])
		}
	}
}

export const userGrid = createUserGrid();