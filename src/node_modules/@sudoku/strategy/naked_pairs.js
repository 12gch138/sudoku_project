import {Strategy} from "./strategy.js"
import { basic_strategy } from "./basic.js"

class Naked_Pairs_Strategy extends Strategy {
    constructor() {
        super('Naked_Pairs');
    }

    get_candidate(board) {
        // 获取基础候选值
        let candidates = basic_strategy.get_candidate(board);

        // 处理裸对
        this.handleNakedPairs(board, candidates);

        return candidates;
    }

    findCandidates(board, row, col) {
        const boxRow = Math.floor(row / 3) * 3;
        const boxCol = Math.floor(col / 3) * 3;
        const usedNumbers = new Set();

        // 检查行
        for (let i = 0; i < 9; i++) {
            const cellValue = board[row][i];
            if (cellValue!== 0) {
                usedNumbers.add(cellValue);
            }
        }

        // 检查列
        for (let i = 0; i < 9; i++) {
            const cellValue = board[i][col];
            if (cellValue!== 0) {
                usedNumbers.add(cellValue);
            }
        }

        // 检查九宫格
        for (let i = boxRow; i < boxRow + 3; i++) {
            for (let j = boxCol; j < boxCol + 3; j++) {
                const cellValue = board[i][j];
                if (cellValue!== 0) {
                    usedNumbers.add(cellValue);
                }
            }
        }

        const candidateList = [];
        for (let i = 1; i <= 9; i++) {
            if (!usedNumbers.has(i)) {
                candidateList.push(i);
            }
        }

        return candidateList;
    }

    handleNakedPairs(board, candidates) {
        // 检查行中的裸对
        for (let row = 0; row < 9; row++) {
            const pairs = this.findNakedPairsInRow(board, row, candidates);
            if (pairs.length > 0) {
                this.removeCandidatesFromRow(board, pairs, row, candidates);
            }
        }

        // 检查列中的裸对
        for (let col = 0; col < 9; col++) {
            const pairs = this.findNakedPairsInColumn(board, col, candidates);
            if (pairs.length > 0) {
                this.removeCandidatesFromColumn(board, pairs, col, candidates);
            }
        }

        // 检查九宫格中的裸对
        for (let box = 0; box < 9; box++) {
            const pairs = this.findNakedPairsInBox(board, box, candidates);
            if (pairs.length > 0) {
                this.removeCandidatesFromBox(board, pairs, box, candidates);
            }
        }
    }

    findNakedPairsInRow(board, row, candidates) {
        const pairs = [];
        const rowCandidates = [];
        const pos = [];
        for (let col = 0; col < 9; col++) {
            if (board[row][col] == 0 && candidates[row][col].length == 2) {
                rowCandidates.push(candidates[row][col]);
                pos.push({row, col});
            }
        }

        for (let i = 0; i < rowCandidates.length; i++) {
            for (let j = i + 1; j < rowCandidates.length; j++) {
                const intersection = rowCandidates[i].filter(num => rowCandidates[j].includes(num));
                if (intersection.length == 2) {
                    pairs.push({
                        numbers: intersection,
                        cells: [
                            pos[i], pos[j]
                        ]
                    });
                }
            }
        }

        return pairs;
    }

    findNakedPairsInColumn(board, col, candidates) {
        const pairs = [];
        const columnCandidates = [];
        const pos = [];
        for (let row = 0; row < 9; row++) {
            if (board[row][col] == 0 && candidates[row][col].length == 2) {
                columnCandidates.push(candidates[row][col]);
                pos.push({row, col});
            }
        }

        for (let i = 0; i < columnCandidates.length; i++) {
            for (let j = i + 1; j < columnCandidates.length; j++) {
                const intersection = columnCandidates[i].filter(num => columnCandidates[j].includes(num));
                if (intersection.length == 2) {
                    pairs.push({
                        numbers: intersection,
                        cells: [
                            pos[i], pos[j]
                        ]
                    });
                }
            }
        }

        return pairs;
    }

    findNakedPairsInBox(board, boxIndex, candidates) {
        const pairs = [];
        const boxRow = Math.floor(boxIndex / 3) * 3;
        const boxCol = (boxIndex % 3) * 3;
        const boxCandidates = [];
        const pos = [];
        for (let row = boxRow; row < boxRow + 3; row++) {
            for (let col = boxCol; col < boxCol + 3; col++) {
                if (board[row][col] == 0 && candidates[row][col].length == 2) {
                    boxCandidates.push(candidates[row][col]);
                    pos.push({row, col});
                }
            }
        }

        for (let i = 0; i < boxCandidates.length; i++) {
            for (let j = i + 1; j < boxCandidates.length; j++) {
                const intersection = boxCandidates[i].filter(num => boxCandidates[j].includes(num));
                if (intersection.length == 2) {
                    pairs.push({
                        numbers: intersection,
                        cells: [
                            pos[i], pos[j]
                        ]
                    });
                }
            }
        }

        return pairs;
    }

    removeCandidatesFromRow(board, pairs, row, candidates) {
        for (const pair of pairs) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] == 0 && !pair.cells.some(cell => cell.col == col)) {
                    const newCandidates = candidates[row][col].filter(num =>!pair.numbers.includes(num));
                    candidates[row][col] = newCandidates;
                }
            }
        }
    }

    removeCandidatesFromColumn(board, pairs, col, candidates) {
        for (const pair of pairs) {
            for (let row = 0; row < 9; row++) {
                if (board[row][col] == 0 && !pair.cells.some(cell => cell.row == row)) {
                    const newCandidates = candidates[row][col].filter(num =>!pair.numbers.includes(num));
                    candidates[row][col] = newCandidates;
                }
            }
        }
    }

    removeCandidatesFromBox(board, pairs, boxIndex, candidates) {
        const boxRow = Math.floor(boxIndex / 3) * 3;
        const boxCol = (boxIndex % 3) * 3;
        for (const pair of pairs) {
            for (let row = boxRow; row < boxRow + 3; row++) {
                for (let col = boxCol; col < boxCol + 3; col++) {
                    if (board[row][col] == 0 && !(pair.cells[0].row == row && pair.cells[0].col == col) && !(pair.cells[1].row == row && pair.cells[1].col == col)) {
                        const newCandidates = candidates[row][col].filter(num =>!pair.numbers.includes(num));
                        candidates[row][col] = newCandidates;
                    }
                }
            }
        }
    }
}

export const naked_pairs_strategy = new Naked_Pairs_Strategy();