import {Strategy} from "./strategy.js"
import { basic_strategy } from "./basic.js"

class Naked_Quad_Strategy extends Strategy {
    constructor() {
        super('Naked_Quad');
    }

    get_candidate(board) {
        let candidates = basic_strategy.get_candidate(board);
        this.handleNakedQuads(board, candidates);
        return candidates;
    }

    handleNakedQuads(board, candidates) {
        // 检查行中的裸四元组
        for (let row = 0; row < 9; row++) {
            const quads = this.findNakedQuadsInRow(board, row, candidates);
            if (quads.length > 0) {
                this.removeCandidatesFromRow(board, quads, row, candidates);
            }
        }

        // 检查列中的裸四元组
        for (let col = 0; col < 9; col++) {
            const quads = this.findNakedQuadsInColumn(board, col, candidates);
            if (quads.length > 0) {
                this.removeCandidatesFromColumn(board, quads, col, candidates);
            }
        }

        // 检查九宫格中的裸四元组
        for (let box = 0; box < 9; box++) {
            const quads = this.findNakedQuadsInBox(board, box, candidates);
            if (quads.length > 0) {
                this.removeCandidatesFromBox(board, quads, box, candidates);
            }
        }
    }

    findNakedQuadsInRow(board, row, candidates) {
        const quads = [];
        const rowCandidates = [];
        const pos = [];

        // 收集该行中候选数字数量为2-4的单元格
        for (let col = 0; col < 9; col++) {
            if (board[row][col] == 0 && candidates[row][col].length <= 4) {
                rowCandidates.push(candidates[row][col]);
                pos.push({row, col});
            }
        }

        // 检查任意四个单元格的组合
        for (let i = 0; i < rowCandidates.length - 3; i++) {
            for (let j = i + 1; j < rowCandidates.length - 2; j++) {
                for (let k = j + 1; k < rowCandidates.length - 1; k++) {
                    for (let l = k + 1; l < rowCandidates.length; l++) {
                        // 获取四个单元格的所有候选数字的并集
                        const uniqueNumbers = new Set([
                            ...rowCandidates[i],
                            ...rowCandidates[j],
                            ...rowCandidates[k],
                            ...rowCandidates[l]
                        ]);

                        // 如果并集恰好包含四个数字，这就是一个裸四元组
                        if (uniqueNumbers.size === 4) {
                            quads.push({
                                numbers: Array.from(uniqueNumbers),
                                cells: [pos[i], pos[j], pos[k], pos[l]]
                            });
                        }
                    }
                }
            }
        }

        return quads;
    }

    findNakedQuadsInColumn(board, col, candidates) {
        const quads = [];
        const colCandidates = [];
        const pos = [];

        for (let row = 0; row < 9; row++) {
            if (board[row][col] == 0 && candidates[row][col].length <= 4) {
                colCandidates.push(candidates[row][col]);
                pos.push({row, col});
            }
        }

        for (let i = 0; i < colCandidates.length - 3; i++) {
            for (let j = i + 1; j < colCandidates.length - 2; j++) {
                for (let k = j + 1; k < colCandidates.length - 1; k++) {
                    for (let l = k + 1; l < colCandidates.length; l++) {
                        const uniqueNumbers = new Set([
                            ...colCandidates[i],
                            ...colCandidates[j],
                            ...colCandidates[k],
                            ...colCandidates[l]
                        ]);

                        if (uniqueNumbers.size === 4) {
                            quads.push({
                                numbers: Array.from(uniqueNumbers),
                                cells: [pos[i], pos[j], pos[k], pos[l]]
                            });
                        }
                    }
                }
            }
        }

        return quads;
    }

    findNakedQuadsInBox(board, boxIndex, candidates) {
        const quads = [];
        const boxRow = Math.floor(boxIndex / 3) * 3;
        const boxCol = (boxIndex % 3) * 3;
        const boxCandidates = [];
        const pos = [];

        for (let row = boxRow; row < boxRow + 3; row++) {
            for (let col = boxCol; col < boxCol + 3; col++) {
                if (board[row][col] == 0 && candidates[row][col].length <= 4) {
                    boxCandidates.push(candidates[row][col]);
                    pos.push({row, col});
                }
            }
        }

        for (let i = 0; i < boxCandidates.length - 3; i++) {
            for (let j = i + 1; j < boxCandidates.length - 2; j++) {
                for (let k = j + 1; k < boxCandidates.length - 1; k++) {
                    for (let l = k + 1; l < boxCandidates.length; l++) {
                        const uniqueNumbers = new Set([
                            ...boxCandidates[i],
                            ...boxCandidates[j],
                            ...boxCandidates[k],
                            ...boxCandidates[l]
                        ]);

                        if (uniqueNumbers.size === 4) {
                            quads.push({
                                numbers: Array.from(uniqueNumbers),
                                cells: [pos[i], pos[j], pos[k], pos[l]]
                            });
                        }
                    }
                }
            }
        }

        return quads;
    }

    removeCandidatesFromRow(board, quads, row, candidates) {
        for (const quad of quads) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] == 0 && !quad.cells.some(cell => cell.col == col)) {
                    candidates[row][col] = candidates[row][col].filter(
                        num => !quad.numbers.includes(num)
                    );
                }
            }
        }
    }

    removeCandidatesFromColumn(board, quads, col, candidates) {
        for (const quad of quads) {
            for (let row = 0; row < 9; row++) {
                if (board[row][col] == 0 && !quad.cells.some(cell => cell.row == row)) {
                    candidates[row][col] = candidates[row][col].filter(
                        num => !quad.numbers.includes(num)
                    );
                }
            }
        }
    }

    removeCandidatesFromBox(board, quads, boxIndex, candidates) {
        const boxRow = Math.floor(boxIndex / 3) * 3;
        const boxCol = (boxIndex % 3) * 3;
        
        for (const quad of quads) {
            for (let row = boxRow; row < boxRow + 3; row++) {
                for (let col = boxCol; col < boxCol + 3; col++) {
                    if (board[row][col] == 0 && 
                        !quad.cells.some(cell => cell.row == row && cell.col == col)) {
                        candidates[row][col] = candidates[row][col].filter(
                            num => !quad.numbers.includes(num)
                        );
                    }
                }
            }
        }
    }
}

export const naked_quad_strategy = new Naked_Quad_Strategy(); 