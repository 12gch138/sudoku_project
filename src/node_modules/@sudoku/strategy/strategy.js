// 抽象策略类
class Strategy {
    constructor(name) {
        if (this.constructor === Strategy) {
            throw new Error('Abstract classes can\'t be instantiated.');
        }
        this.name = name;
    }

    get_candidate(board) {
        throw new Error('Abstract method must be implemented in derived classes.');
    }
}

// 策略管理器类
class StrategyManager {
    constructor() {
        this.strategies = [];
        this.candidateLists = [];
    }

    addStrategy(strategy) {
        if (!(strategy instanceof Strategy)) {
            throw new Error('Only instances of Strategy can be added.');
        }
        this.strategies.push(strategy);
    }

    removeStrategy(strategy) {
        const index = this.strategies.indexOf(strategy);
        if (index!== -1) {
            this.strategies.splice(index, 1);
        }
    }

    executeStrategies(board) {
        this.candidateLists = [];
        for (const strategy of this.strategies) {
            const candidates = strategy.get_candidate(board);
            this.candidateLists.push(candidates);
        }
    }

    getIntersectionCandidates() {
        if (this.candidateLists.length === 0) {
            return {};
        }

        let intersection = new Map(Object.entries(this.candidateLists[0]));
        for (let i = 1; i < this.candidateLists.length; i++) {
            const currentCandidates = this.candidateLists[i];
            const newIntersection = new Map();
            for (const [key, value] of intersection) {
                if (currentCandidates[key]) {
                    newIntersection.set(key, value.filter(v => currentCandidates[key].includes(v)));
                }
            }
            intersection = newIntersection;
        }

        return Object.fromEntries(intersection);
    }
}