import { Strategy } from "./strategy.js";
import { basic_strategy } from "./basic.js";

// 辅助函数：查找组合
function findGroups(groupLen) {
    return function(items) {
        if (items.length < groupLen) return [];
        if (groupLen === 1) return items.map(item => [item]);
        
        const combinations = [];
        items.forEach((item, index) => {
            const remainingItems = items.slice(index + 1);
            const subCombinations = findGroups(groupLen - 1)(remainingItems);
            subCombinations.forEach(subComb => {
                combinations.push([item, ...subComb]);
            });
        });
        return combinations;
    };
}

class Fish_Strategy extends Strategy {
    constructor(fishLen, description) {
        super(`Fish_${description}`);
        this.fishLen = fishLen;
        this.description = description;
    }

    get_candidate(board) {
        // 获取基础候选值
        let candidates = basic_strategy.get_candidate(board);
        
        // 处理Fish策略
        this.handleFish(board, candidates);
        
        return candidates;
    }

    handleFish(board, candidates) {
        // 将二维数组转换为一维数组格式以匹配原fish.js的输入格式
        const flatGrid = this.convertToFlatGrid(board, candidates);
        
        // 获取所有开放的单元格
        const openCells = this.getOpen(flatGrid);
        const possibleAnswers = this.getUniqueOpenValues(openCells, flatGrid);

        // 获取行列集合
        const openRows = Array(9).fill().map((_, i) => 
            this.getOpenInRow(i, flatGrid));
        const openColumns = Array(9).fill().map((_, i) => 
            this.getOpenInColumn(i, flatGrid));

        // 对每个可能的答案进行Fish模式检查
        for (const answer of possibleAnswers) {
            const rowSets = this.findFishInRows(answer, openRows, flatGrid);
            const columnSets = this.findFishInColumns(answer, openColumns, flatGrid);
            
            // 应用找到的Fish模式来更新候选值
            this.applyFishPatterns(rowSets, columnSets, candidates, answer);
        }
    }

    convertToFlatGrid(board, candidates) {
        const flatGrid = new Array(81);
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                const index = row * 9 + col;
                flatGrid[index] = board[row][col] === 0 ? 
                    candidates[row][col] : [board[row][col]];
            }
        }
        return flatGrid;
    }

    getOpen(flatGrid) {
        return flatGrid.map((_, i) => i)
            .filter(i => flatGrid[i].length > 1);
    }

    getUniqueOpenValues(cells, flatGrid) {
        const values = new Set();
        cells.forEach(cell => {
            flatGrid[cell].forEach(val => values.add(val));
        });
        return Array.from(values);
    }

    getOpenInRow(row, flatGrid) {
        return Array(9).fill().map((_, col) => row * 9 + col)
            .filter(i => flatGrid[i].length > 1);
    }

    getOpenInColumn(col, flatGrid) {
        return Array(9).fill().map((_, row) => row * 9 + col)
            .filter(i => flatGrid[i].length > 1);
    }

    findFishInRows(answer, openRows, flatGrid) {
        const validRows = openRows
            .map((row, i) => ({
                index: i,
                cells: row.filter(cell => flatGrid[cell].includes(answer))
            }))
            .filter(row => row.cells.length >= 2 && row.cells.length <= this.fishLen);

        return this.findFishPatterns(validRows);
    }

    findFishInColumns(answer, openColumns, flatGrid) {
        const validColumns = openColumns
            .map((col, i) => ({
                index: i,
                cells: col.filter(cell => flatGrid[cell].includes(answer))
            }))
            .filter(col => col.cells.length >= 2 && col.cells.length <= this.fishLen);

        return this.findFishPatterns(validColumns);
    }

    findFishPatterns(sets) {
        if (sets.length < this.fishLen) return [];
        
        // 找到所有可能的组合
        const combinations = findGroups(this.fishLen)(sets);
        const patterns = [];

        for (const combo of combinations) {
            const cells = combo.flatMap(set => set.cells);
            
            // 修改这里以正确处理行/列的交叉
            const crossLines = [...new Set(cells.map(cell => {
                // 需要根据是行集合还是列集合来决定
                const isRowSet = true; // 需要添加判断逻辑
                return isRowSet ? cell % 9 : Math.floor(cell / 9);
            }))];

            // 添加更严格的验证
            if (this.isValidFishPattern(cells, crossLines)) {
                const externalCells = this.findExternalCells(combo, crossLines);
                if (externalCells.length > 0) {
                    patterns.push({
                        cells: cells,
                        externalCells: externalCells,
                        baseUnits: combo.map(set => set.index)
                    });
                }
            }
        }

        return patterns;
    }

    findExternalCells(combo, crossLines) {
        const baseUnits = combo.map(set => set.index);
        const allCells = new Set(combo.flatMap(set => set.cells));
        const externalCells = [];
        
        // 需要添加判断是行集合还是列集合的逻辑
        const isRowSet = true; // 需要添加判断逻辑
        
        for (const line of crossLines) {
            for (let i = 0; i < 9; i++) {
                const cell = isRowSet ? 
                    i * 9 + line :  // 如果是行集合，检查列
                    line * 9 + i;   // 如果是列集合，检查行
                
                if (!allCells.has(cell) && !baseUnits.includes(isRowSet ? 
                    Math.floor(cell / 9) : cell % 9)) {
                    externalCells.push(cell);
                }
            }
        }
        
        return externalCells;
    }

    // 添加新的辅助方法
    isRowSet(combo) {
        // 通过检查第一个单元格的索引范围来判断是行集合还是列集合
        const firstCell = combo[0].cells[0];
        const row = Math.floor(firstCell / 9);
        return combo[0].cells.every(cell => Math.floor(cell / 9) === row);
    }

    applyFishPatterns(rowSets, columnSets, candidates, answer) {
        const allSets = [...rowSets, ...columnSets];
        
        for (const pattern of allSets) {
            // 从外部单元格中移除候选值
            this.removeCandidateFromCells(pattern.externalCells, candidates, answer);
        }
    }

    // 优化现有的removeCandidateFromCells方法
    removeCandidateFromCells(cells, candidates, value) {
        cells.forEach(cell => {
            const row = Math.floor(cell / 9);
            const col = cell % 9;
            if (candidates[row][col].includes(value)) {
                candidates[row][col] = candidates[row][col]
                    .filter(num => num !== value);
            }
        });
    }

    // 添加辅助方法来检查是否为有效的Fish模式
    isValidFishPattern(cells, crossLines) {
        // 检查基本单元数量是否等于fish长度
        const baseUnits = new Set(cells.map(cell => Math.floor(cell / 9)));
        if (baseUnits.size !== this.fishLen) return false;

        // 检查交叉线数量是否等于fish长度
        if (crossLines.length !== this.fishLen) return false;

        return true;
    }
}

// 创建不同大小的Fish策略实例
export const x_wing_strategy = new Fish_Strategy(2, "X-Wing");
export const swordfish_strategy = new Fish_Strategy(3, "Swordfish");
export const jellyfish_strategy = new Fish_Strategy(4, "Jellyfish"); 