/// 暂未通过测试，待修改
import { Strategy } from "./strategy.js";
import { basic_startegy } from "./basic.js";

class Box_Line_Reduction_Strategy extends Strategy {
    constructor() {
        super('Box_Line_Reduction');
    }

    get_candidate(board) {
        let candidates = basic_startegy.get_candidate(board);
        let changed = true;

        // 循环处理直到没有变化
        while (changed) {
            // 保存处理前的状态，用于比较是否有变化
            const previousState = JSON.stringify(candidates);

            this.handleBoxLineReduction(board, candidates);

            // 比较处理后的状态，检查是否有变化
            const currentState = JSON.stringify(candidates);
            changed = previousState !== currentState;
        }
        return candidates;
    }

    handleBoxLineReduction(board, candidates) {
        // 添加调试日志
        //console.log('开始处理 Box/Line Reduction');
        //console.log('初始候选数:', JSON.stringify(candidates));

        // 检查所有行中的Box/Line Reduction
        for (let row = 0; row < 9; row++) {
            const eliminations = this.findAndEliminateInRow(board, row, candidates);
            if (eliminations && eliminations.length > 0) {
                // 处理后的消除逻辑
                console.log(`在第 ${row} 行进行了消除:`, eliminations);
            }
        }

        // 检查所有列中的Box/Line Reduction
        for (let col = 0; col < 9; col++) {
            const eliminations = this.findAndEliminateInColumn(board, col, candidates);
            if (eliminations && eliminations.length > 0) {
                // 处理后的消除逻辑
                console.log(`在第 ${col} 列进行了消除:`, eliminations);
            }
        }

        // 检查所有盒子中的Box/Line Reduction
        for (let box = 0; box < 9; box++) {
            const eliminations = this.findAndEliminateInBox(board, box, candidates);
            if (eliminations && eliminations.length > 0) {
                // 处理后的消除逻辑
                console.log(`在第 ${box} 盒进行了消除:`, eliminations);
            }
        }
    }

    findAndEliminateInRow(board, row, candidates) {
        for (let num = 1; num <= 9; num++) {
            let positions = [];
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === 0 && candidates[row][col].includes(num)) {
                    positions.push({ row, col });
                }
            }

            if (positions.length === 2 || positions.length === 3) {
                // 检查这些位置是否都在同一个盒子
                const boxIndices = positions.map(pos => this.getBoxIndex(pos.row, pos.col));
                const uniqueBoxes = new Set(boxIndices);
                if (uniqueBoxes.size === 1) {
                    const box = boxIndices[0];
                    // 从该盒子之外的行中删除该数字
                    this.eliminateFromBoxExcept(box, num, positions, candidates);
                }
            }
        }
    }

    findAndEliminateInColumn(board, col, candidates) {
        for (let num = 1; num <= 9; num++) {
            let positions = [];
            for (let row = 0; row < 9; row++) {
                if (board[row][col] === 0 && candidates[row][col].includes(num)) {
                    positions.push({ row, col });
                }
            }

            if (positions.length === 2 || positions.length === 3) {
                // 检查这些位置是否都在同一个盒子
                const boxIndices = positions.map(pos => this.getBoxIndex(pos.row, pos.col));
                const uniqueBoxes = new Set(boxIndices);
                if (uniqueBoxes.size === 1) {
                    const box = boxIndices[0];
                    // 从该盒子之外的列中删除该数字
                    this.eliminateFromBoxExcept(box, num, positions, candidates);
                }
            }
        }
    }

    findAndEliminateInBox(board, box, candidates) {
        const boxRow = Math.floor(box / 3) * 3;
        const boxCol = (box % 3) * 3;
        const numberPositions = new Map();

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const row = boxRow + i;
                const col = boxCol + j;
                if (board[row][col] === 0) {
                    for (const num of candidates[row][col]) {
                        if (!numberPositions.has(num)) {
                            numberPositions.set(num, []);
                        }
                        numberPositions.get(num).push({ row, col });
                    }
                }
            }
        }

        numberPositions.forEach((positions, num) => {
            if (positions.length === 2 || positions.length === 3) {
                // 检查这些位置是否在同一行或同一列
                const rows = new Set(positions.map(pos => pos.row));
                const cols = new Set(positions.map(pos => pos.col));

                if (rows.size === 1) {
                    const row = [...rows][0];
                    // 从该行之外的盒子中删除该数字
                    this.eliminateFromRowExcept(row, num, positions, candidates);
                }

                if (cols.size === 1) {
                    const col = [...cols][0];
                    // 从该列之外的盒子中删除该数字
                    this.eliminateFromColumnExcept(col, num, positions, candidates);
                }
            }
        });
    }

    eliminateFromBoxExcept(box, num, positions, candidates) {
        const boxRow = Math.floor(box / 3) * 3;
        const boxCol = (box % 3) * 3;

        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                const row = boxRow + i;
                const col = boxCol + j;
                if (!positions.some(pos => pos.row === row && pos.col === col)) {
                    const idx = candidates[row][col].indexOf(num);
                    if (idx !== -1) {
                        candidates[row][col].splice(idx, 1);
                    }
                }
            }
        }
    }

    eliminateFromRowExcept(row, num, positions, candidates) {
        // 获取positions所在的盒子索引集合
        const boxSet = new Set(positions.map(pos => this.getBoxIndex(pos.row, pos.col)));
        
        for (let col = 0; col < 9; col++) {
            const box = this.getBoxIndex(row, col);
            // 如果当前位置不在指定的盒子中
            if (!boxSet.has(box)) {
                // 确保candidates[row][col]存在且是数组
                if (Array.isArray(candidates[row][col])) {
                    const idx = candidates[row][col].indexOf(num);
                    if (idx !== -1) {
                        candidates[row][col].splice(idx, 1);
                    }
                }
            }
        }
    }

    eliminateFromColumnExcept(col, num, positions, candidates) {
        // 获取positions所在的盒子索引集合
        const boxSet = new Set(positions.map(pos => this.getBoxIndex(pos.row, pos.col)));
        
        for (let row = 0; row < 9; row++) {
            const box = this.getBoxIndex(row, col);
            // 如果当前位置不在指定的盒子中
            if (!boxSet.has(box)) {
                // 确保candidates[row][col]存在且是数组
                if (Array.isArray(candidates[row][col])) {
                    const idx = candidates[row][col].indexOf(num);
                    if (idx !== -1) {
                        candidates[row][col].splice(idx, 1);
                    }
                }
            }
        }
    }

    getBoxIndex(row, col) {
        return Math.floor(row / 3) * 3 + Math.floor(col / 3);
    }
}

export const box_line_reduction_strategy = new Box_Line_Reduction_Strategy();