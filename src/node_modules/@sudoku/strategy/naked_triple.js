import {Strategy} from "./strategy.js"
import { basic_strategy } from "./basic.js"

class Naked_Triple_Strategy extends Strategy {
    constructor() {
        super('Naked_Triple');
    }

    get_candidate(board) {
        let candidates = basic_strategy.get_candidate(board);
        this.handleNakedTriples(board, candidates);
        return candidates;
    }

    handleNakedTriples(board, candidates) {
        // 检查行中的裸三元组
        for (let row = 0; row < 9; row++) {
            const triples = this.findNakedTriplesInRow(board, row, candidates);
            if (triples.length > 0) {
                this.removeCandidatesFromRow(board, triples, row, candidates);
            }
        }

        // 检查列中的裸三元组
        for (let col = 0; col < 9; col++) {
            const triples = this.findNakedTriplesInColumn(board, col, candidates);
            if (triples.length > 0) {
                this.removeCandidatesFromColumn(board, triples, col, candidates);
            }
        }

        // 检查九宫格中的裸三元组
        for (let box = 0; box < 9; box++) {
            const triples = this.findNakedTriplesInBox(board, box, candidates);
            if (triples.length > 0) {
                this.removeCandidatesFromBox(board, triples, box, candidates);
            }
        }
    }

    findNakedTriplesInRow(board, row, candidates) {
        const triples = [];
        const rowCandidates = [];
        const pos = [];

        // 收集该行中候选数字数量为2或3的单元格
        for (let col = 0; col < 9; col++) {
            if (board[row][col] == 0 && candidates[row][col].length <= 3) {
                rowCandidates.push(candidates[row][col]);
                pos.push({row, col});
            }
        }

        // 检查任意三个单元格的组合
        for (let i = 0; i < rowCandidates.length - 2; i++) {
            for (let j = i + 1; j < rowCandidates.length - 1; j++) {
                for (let k = j + 1; k < rowCandidates.length; k++) {
                    // 获取三个单元格的所有候选数字的并集
                    const uniqueNumbers = new Set([
                        ...rowCandidates[i],
                        ...rowCandidates[j],
                        ...rowCandidates[k]
                    ]);

                    // 如果并集恰好包含三个数字，这就是一个裸三元组
                    if (uniqueNumbers.size === 3) {
                        triples.push({
                            numbers: Array.from(uniqueNumbers),
                            cells: [pos[i], pos[j], pos[k]]
                        });
                    }
                }
            }
        }

        return triples;
    }

    findNakedTriplesInColumn(board, col, candidates) {
        const triples = [];
        const colCandidates = [];
        const pos = [];

        for (let row = 0; row < 9; row++) {
            if (board[row][col] == 0 && candidates[row][col].length <= 3) {
                colCandidates.push(candidates[row][col]);
                pos.push({row, col});
            }
        }

        for (let i = 0; i < colCandidates.length - 2; i++) {
            for (let j = i + 1; j < colCandidates.length - 1; j++) {
                for (let k = j + 1; k < colCandidates.length; k++) {
                    const uniqueNumbers = new Set([
                        ...colCandidates[i],
                        ...colCandidates[j],
                        ...colCandidates[k]
                    ]);

                    if (uniqueNumbers.size === 3) {
                        triples.push({
                            numbers: Array.from(uniqueNumbers),
                            cells: [pos[i], pos[j], pos[k]]
                        });
                    }
                }
            }
        }

        return triples;
    }

    findNakedTriplesInBox(board, boxIndex, candidates) {
        const triples = [];
        const boxRow = Math.floor(boxIndex / 3) * 3;
        const boxCol = (boxIndex % 3) * 3;
        const boxCandidates = [];
        const pos = [];

        for (let row = boxRow; row < boxRow + 3; row++) {
            for (let col = boxCol; col < boxCol + 3; col++) {
                if (board[row][col] == 0 && candidates[row][col].length <= 3) {
                    boxCandidates.push(candidates[row][col]);
                    pos.push({row, col});
                }
            }
        }

        for (let i = 0; i < boxCandidates.length - 2; i++) {
            for (let j = i + 1; j < boxCandidates.length - 1; j++) {
                for (let k = j + 1; k < boxCandidates.length; k++) {
                    const uniqueNumbers = new Set([
                        ...boxCandidates[i],
                        ...boxCandidates[j],
                        ...boxCandidates[k]
                    ]);

                    if (uniqueNumbers.size === 3) {
                        triples.push({
                            numbers: Array.from(uniqueNumbers),
                            cells: [pos[i], pos[j], pos[k]]
                        });
                    }
                }
            }
        }

        return triples;
    }

    removeCandidatesFromRow(board, triples, row, candidates) {
        for (const triple of triples) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] == 0 && !triple.cells.some(cell => cell.col == col)) {
                    candidates[row][col] = candidates[row][col].filter(
                        num => !triple.numbers.includes(num)
                    );
                }
            }
        }
    }

    removeCandidatesFromColumn(board, triples, col, candidates) {
        for (const triple of triples) {
            for (let row = 0; row < 9; row++) {
                if (board[row][col] == 0 && !triple.cells.some(cell => cell.row == row)) {
                    candidates[row][col] = candidates[row][col].filter(
                        num => !triple.numbers.includes(num)
                    );
                }
            }
        }
    }

    removeCandidatesFromBox(board, triples, boxIndex, candidates) {
        const boxRow = Math.floor(boxIndex / 3) * 3;
        const boxCol = (boxIndex % 3) * 3;
        
        for (const triple of triples) {
            for (let row = boxRow; row < boxRow + 3; row++) {
                for (let col = boxCol; col < boxCol + 3; col++) {
                    if (board[row][col] == 0 && 
                        !triple.cells.some(cell => cell.row == row && cell.col == col)) {
                        candidates[row][col] = candidates[row][col].filter(
                            num => !triple.numbers.includes(num)
                        );
                    }
                }
            }
        }
    }
}

export const naked_triple_strategy = new Naked_Triple_Strategy(); 